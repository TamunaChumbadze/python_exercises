"""
head                             tail

(11) --> (3) --> (23) --> (7) --> (4) --> None

"""


"""
თითო ელემენტი (ანუ Node) შეიცავს:

"value" — მონაცემს (მაგალითად 11, 3, 23...),

"next" — ბმულს (მაჩვენებელს) შემდეგ ელემენტზე.

თუ შემდეგი ელემენტი არ არსებობს, მაშინ "next" მიიღებს მნიშვნელობას None.

"""

head = {
    "value": 11,
    "next": {
        "value": 3,
        "next": {
            "value": 23,
            "next": {
                "value": 7,
                "next": {
                    "value": 4,
                    "next": None
                },
            },
        },
    },
}

print("Head:", head["value"])
tail = head["next"]["next"]["next"]["next"]["value"]
print("Tail:", tail)


"""
head = პირველი ელემენტი (value = 11)

tail = ბოლო ელემენტი (value = 4)

next = "მაჩვენებელი" შემდეგ ელემენტზე

None = ბოლოს აღარ არსებობს სხვა ელემენტი

length = ელემენტების რაოდენობა (6)

"""

"""
| ელემენტი         | დიქშნერებში     | კლასებში                |
| ---------------- | --------------- | ----------------------- |
| მონაცემი         | `"value": 11`   | `self.value = 11`       |
| შემდეგი ელემენტი | `"next": {...}` | `self.next = next_node` |
| პირველი ელემენტი | `head`          | `self.head`             |
| ბოლო ელემენტი    | `tail`          | `self.tail`             |
| რაოდენობა       | `length`        | `self.length`           |
"""

"""
- დიქშნერებით შენ უბრალოდ ხელით აგებ სტრუქტურას.
- კლასებით კი ქმნი რეალურ მონაცემთა ტიპს, რომელსაც შეგიძლია მეთოდებიც დაუმატო —
- მაგალითად append, pop, insert და ა.შ.
- კლასები უფრო მოქნილია და რეალურ სამყაროში უკეთესად მუშაობს.

"""